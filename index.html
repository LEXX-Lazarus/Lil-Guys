<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lil Guys Pet Care</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font for a pixelated feel, or a clean look */
        body {
            font-family: 'Press Start 2P', cursive; /* A pixelated font, if available */
            font-family: 'Inter', sans-serif; /* Fallback for a clean look */
            image-rendering: pixelated; /* Ensures pixel art stays sharp */
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        /* Ensure the app takes full screen when added to home screen */
        html, body {
            min-height: 100vh; /* Use min-height to ensure it's at least viewport height */
            margin: 0;
            display: flex; /* Make body a flex container */
            flex-direction: column; /* Stack children vertically */
            /* Removed overflow: hidden; to allow vertical scrolling on smaller screens */
        }

        /* Custom scrollbar for pet list and food area */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #2d3748; /* bg-gray-800 */
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #a78bfa; /* bg-purple-400 */
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #8b5cf6; /* bg-purple-500 */
        }

        /* Keyframe for happiness animation */
        @keyframes pulse-happiness {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .animate-pulse-happiness {
            animation: pulse-happiness 0.5s ease-out;
        }

        /* Keyframe for food animation */
        @keyframes pop-food {
            0% { transform: scale(0); opacity: 0; }
            70% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        .animate-pop-food {
            animation: pop-food 0.3s ease-out;
        }

        /* Modal overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #2d3748; /* bg-gray-800 */
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            width: 400px;
            text-align: center;
            border: 2px solid #a78bfa; /* purple-400 */
        }

        /* Speech Bubble Styles */
        .speech-bubble {
            position: absolute;
            background: #fff;
            border-radius: 0.5rem;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem; /* text-sm */
            color: #1a202c; /* text-gray-900 */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            /* Allow text wrapping on smaller screens */
            z-index: 50;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            max-width: 150px; /* Limit width to prevent excessive horizontal growth */
            text-align: center;
        }

        .speech-bubble.show {
            opacity: 1;
            transform: translateY(0);
        }

        /* Triangle for speech bubble */
        .speech-bubble::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border: 10px solid transparent;
            border-top-color: #fff;
            border-bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            bottom: -10px;
        }
    </style>

    <!-- PWA / iOS Home Screen Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Lil Guys">
    <link rel="apple-touch-icon" href="https://placehold.co/180x180/6b46c1/FFFFFF?text=üêæ">

    <!-- Basic Web App Manifest -->
    <link rel="manifest" href="/manifest.json">
</head>
<body class="bg-gradient-to-br from-purple-900 to-indigo-700 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="fixed inset-0 bg-gray-900 bg-opacity-90 flex items-center justify-center z-50">
        <div class="text-center">
            <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-purple-500 mx-auto mb-4"></div>
            <p class="text-xl text-purple-300">Loading Lil Guys...</p>
        </div>
    </div>

    <!-- Main App Container -->
    <div class="bg-gray-900 bg-opacity-80 backdrop-blur-sm p-6 md:p-8 rounded-3xl shadow-2xl text-center max-w-4xl w-full flex flex-col md:flex-row gap-6 border border-purple-600 flex-grow">

        <!-- Left Panel: Pet List -->
        <div class="md:w-1/3 w-full bg-gray-800 bg-opacity-70 p-4 rounded-2xl border border-gray-700 flex flex-col shadow-inner md:h-full max-h-[50vh] sm:max-h-[60vh]">
            <h2 class="text-2xl font-bold mb-4 text-purple-300">My Pets</h2>
            <div id="petList" class="flex-grow overflow-y-auto custom-scrollbar space-y-3 pr-2">
                <!-- Pet items will be rendered here -->
            </div>
            <button id="addPetButton" class="mt-6 bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-opacity-75">
                Adopt New Pet
            </button>
        </div>

        <!-- Right Panel: Selected Pet Display & Interaction -->
        <div class="md:w-2/3 w-full bg-gray-800 bg-opacity-70 p-4 rounded-2xl border border-gray-700 flex flex-col justify-between shadow-inner pt-10 md:pt-20">
            <h2 id="selectedPetName" class="text-3xl font-extrabold mb-4 text-pink-300">Select a Pet</h2>

            <!-- Pet Display Area -->
            <div id="petDisplayArea" class="flex flex-col items-center justify-center flex-grow mb-6">
                <div id="petImageContainer" class="relative w-48 h-48 mb-4 flex items-center justify-center">
                    <!-- Pet image will be rendered here -->
                    <span id="petMoodEmoji" class="absolute bottom-0 right-0 text-4xl transform translate-x-4 translate-y-4"></span>
                    <!-- Speech Bubble Element -->
                    <div id="speechBubble" class="speech-bubble absolute -top-16 left-1/2 -translate-x-1/2 hidden"></div>
                </div>
                <div class="w-full bg-gray-700 rounded-full h-4 mb-4 overflow-hidden shadow-md">
                    <div id="happinessBar" class="bg-gradient-to-r from-yellow-400 to-green-500 h-full rounded-full transition-all duration-500 ease-out" style="width: 0%;"></div>
                </div>
                <p id="happinessText" class="text-lg text-gray-300 mb-4">Happiness: 0%</p>

                <!-- Chewing Meter -->
                <p id="chewingText" class="text-sm text-gray-400 mb-2 hidden">Chewing...</p>
                <div class="w-full bg-gray-700 rounded-full h-2 overflow-hidden shadow-md mb-4 hidden" id="chewingMeterContainer">
                    <div id="chewingMeter" class="bg-green-400 h-full rounded-full transition-all duration-100 ease-linear" style="width: 100%;"></div>
                </div>

                <div class="flex items-center space-x-2 mb-4">
                    <input type="text" id="petNameInput" class="bg-gray-700 text-white text-center text-xl p-2 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-400" placeholder="Enter pet name">
                    <button id="saveNameButton" class="bg-purple-500 hover:bg-purple-600 text-white py-2 px-4 rounded-lg shadow transition duration-300 ease-in-out transform hover:scale-105">Save Name</button>
                </div>
            </div>

            <!-- Food Selection Area -->
            <div class="p-4 bg-gray-700 rounded-xl shadow-inner border border-gray-600 max-h-[25vh] overflow-y-auto custom-scrollbar">
                <div id="foodSelectionGrid" class="grid grid-cols-3 gap-4">
                    <!-- Food items will be rendered here by JS -->
                </div>
            </div>
        </div>
    </div>

    <!-- User ID Display (now less relevant for shared data, but useful for debugging) -->
    <div class="mt-4 p-2 bg-gray-900 bg-opacity-70 rounded-lg text-sm text-gray-400 shadow-md border border-gray-700">
        Your User ID: <span id="userIdDisplay" class="font-mono text-purple-300">Loading...</span>
    </div>

    <!-- Modals -->
    <!-- Add Pet Modal -->
    <div id="addPetModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-2xl font-bold mb-6 text-purple-300">Choose Your New Pet!</h3>
            <div id="petTypeSelection" class="grid grid-cols-3 gap-4 mb-6">
                <!-- Pet types will be rendered here -->
            </div>
            <input type="text" id="newPetNameInput" class="bg-gray-700 text-white text-center text-xl p-2 rounded-lg border border-gray-600 w-full mb-6 focus:outline-none focus:ring-2 focus:ring-purple-400" placeholder="Name your new pet">
            <div class="flex justify-around">
                <button id="confirmAddPetButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-5 rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105">Adopt</button>
                <button id="cancelAddPetButton" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-5 rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Message Modal -->
    <div id="messageModal" class="modal-overlay hidden">
        <div class="modal-content">
            <p id="messageModalText" class="text-xl mb-6 text-gray-200"></p>
            <button id="messageModalCloseButton" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-5 rounded-full shadow-lg transition duration-300 ease-in-out transform hover:scale-105">OK</button>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-auth.js";
        import { getFirestore, doc, collection, query, onSnapshot, updateDoc, addDoc, deleteDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.0.0/firebase-firestore.js";

        // IMPORTANT: Replace this with your actual Firebase project config.
        // Go to Firebase Console -> Project settings -> Your apps -> Web app -> Config
        const firebaseConfig = {
            apiKey: "AIzaSyAdkD_covwMgVc1nMMEQwmH-1VGS5opJQ4", // Replace with your Firebase project's API Key
            authDomain: "lil-guys.firebaseapp.com", // Replace with your Auth Domain
            projectId: "lil-guys", // Replace with your Project ID
            storageBucket: "lil-guys.firebasestorage.app", // Replace with your Storage Bucket (use .appspot.com if that's what Firebase console gives you)
            messagingSenderId: "386443044463", // Replace with your Messaging Sender ID
            appId: "1:386443044463:web:ae2f7054687dd68df60f9a", // Replace with your App ID
            measurementId: "G-VHGG43XDXB" // Optional: if you use Google Analytics for Firebase
        };

        // Log the firebaseConfig being used for debugging
        console.log("Firebase Config:", firebaseConfig);

        // Use firebaseConfig.projectId as appId for consistency in data paths
        const appId = firebaseConfig.projectId;

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        let currentUserId = null;
        let userPets = [];
        let selectedPetId = null;
        let unsubscribePets = null; // To store the unsubscribe function for real-time listener
        let speechBubbleTimer = null; // To manage the speech bubble interval
        let chewingTimer = null; // Global variable to hold the chewing animation frame ID
        let currentChewingPetId = null; // To track which pet is currently chewing

        // --- UI Elements ---
        const loadingOverlay = document.getElementById('loadingOverlay');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const petListContainer = document.getElementById('petList');
        const addPetButton = document.getElementById('addPetButton');
        const selectedPetNameElement = document.getElementById('selectedPetName');
        const petImageContainer = document.getElementById('petImageContainer');
        const petMoodEmoji = document.getElementById('petMoodEmoji');
        const happinessBar = document.getElementById('happinessBar');
        const happinessText = document.getElementById('happinessText');
        const chewingText = document.getElementById('chewingText'); // New chewing text element
        const chewingMeterContainer = document.getElementById('chewingMeterContainer'); // New chewing meter container
        const chewingMeter = document.getElementById('chewingMeter'); // New chewing meter bar
        const petNameInput = document.getElementById('petNameInput');
        const saveNameButton = document.getElementById('saveNameButton');
        const foodSelectionGrid = document.getElementById('foodSelectionGrid'); // Changed to foodSelectionGrid
        let speechBubble = null; // Changed to `let` and initialized to `null`

        // Modals
        const addPetModal = document.getElementById('addPetModal');
        const petTypeSelection = document.getElementById('petTypeSelection');
        const newPetNameInput = document.getElementById('newPetNameInput');
        const confirmAddPetButton = document.getElementById('confirmAddPetButton');
        const cancelAddPetButton = document.getElementById('cancelAddPetButton');
        const messageModal = document.getElementById('messageModal');
        const messageModalText = document.getElementById('messageModalText');
        const messageModalCloseButton = document.getElementById('messageModalCloseButton');

        // --- Pet Types and Food Data ---
        const petTypes = [
            { id: 'cat', emoji: 'üê±', name: 'Cat' },
            { id: 'dog', emoji: 'üê∂', name: 'Dog' },
            { id: 'bunny', emoji: 'üê∞', name: 'Bunny' },
            { id: 'hamster', emoji: 'üêπ', name: 'Hamster' },
            { id: 'fish', emoji: 'üê†', name: 'Fish' },
            { id: 'bird', emoji: 'üê¶', name: 'Bird' }
        ];

        // Default happiness values for foods if no specific preference is found
        const foodItems = [
            { emoji: 'üçî', defaultHappiness: 15, color: 'blue' },
            { emoji: 'üçï', defaultHappiness: 12, color: 'yellow' },
            { emoji: 'ü•ï', defaultHappiness: 10, color: 'red' },
            { emoji: 'üçé', defaultHappiness: 8, color: 'green' },
            { emoji: 'üç¶', defaultHappiness: 20, color: 'indigo' },
            { emoji: 'üç©', defaultHappiness: 18, color: 'orange' },
            { emoji: 'üêü', defaultHappiness: 25, color: 'cyan' }, // New food
            { emoji: 'üçñ', defaultHappiness: 20, color: 'brown' }, // New food
            { emoji: 'ü•õ', defaultHappiness: 5, color: 'gray' },   // New food
            { emoji: 'ü•¶', defaultHappiness: 7, color: 'emerald' }, // New food
            { emoji: 'üßÄ', defaultHappiness: 10, color: 'amber' }, // New food
            { emoji: 'üå∞', defaultHappiness: 8, color: 'lime' }    // New food
        ];

        // Specific pet food preferences (override defaultHappiness)
        const petFoodPreferences = {
            'cat': [
                { emoji: 'üçî', change: -10, message: "Yuck, not a fan of burgers!" },
                { emoji: 'ü•ï', change: -5, message: "Carrots? No thanks." },
                { emoji: 'üêü', change: 30, message: "Meow! My favorite fish!" },
                { emoji: 'ü•õ', change: 15, message: "Purrrr, delicious milk!" }
            ],
            'dog': [
                { emoji: 'üçî', change: 20, message: "Woof! My favorite burger!" },
                { emoji: 'üçï', change: 15, message: "Pizza time!" },
                { emoji: 'üêü', change: -5, message: "Fish? I prefer meat!" },
                { emoji: 'üçñ', change: 30, message: "Bone! Best treat ever!" },
                { emoji: 'ü•¶', change: -10, message: "No veggies for me!" }
            ],
            'bunny': [
                { emoji: 'ü•ï', change: 25, message: "Munch munch! Carrots are the best!" },
                { emoji: 'üçé', change: 15, message: "A juicy apple, just for me!" },
                { emoji: 'üçî', change: -20, message: "Ew, what is this?" },
                { emoji: 'ÔøΩ', change: 10, message: "Broccoli is yummy!" }
            ],
            'hamster': [
                { emoji: 'üå∞', change: 25, message: "Squeak! A tasty nut!" },
                { emoji: 'üçé', change: 10, message: "Sweet apple for a little guy!" },
                { emoji: 'üç©', change: -10, message: "Too sweet for me!" }
            ],
            'fish': [
                { emoji: 'ü•¶', change: -5, message: "I don't eat that!" },
                { emoji: 'üêü', change: -10, message: "Hey, that's my cousin!" } // Fish don't eat fish
            ],
            'bird': [
                { emoji: 'üçé', change: 18, message: "Chirp chirp! A fruity treat!" },
                { emoji: 'ü•ï', change: 5, message: "A little crunch!" },
                { emoji: 'üçî', change: -15, message: "Not for birds!" }
            ]
        };


        const petMessages = [
            "Hi there!",
            "I'm so happy!",
            "Feed me, please!",
            "What's up?",
            "Play with me!",
            "I love you!",
            "So cozy here.",
            "I'm feeling good!",
            "Woof! (or Meow!)",
            "Time for a nap?",
            "You're the best!",
            "Feeling playful!",
            "I'm hungry!",
            "Pat me!",
            "Happy to see you!",
            "Let's have fun!",
            "Good to be here.",
            "I'm a Lil Guy!",
            "Feeling cute!",
            "Purrrr...", // Cat specific
            "Bark bark!", // Dog specific
            "Chirp chirp!", // Bird specific
            "Squeak!", // Hamster specific
            "Wiggle wiggle!" // Fish specific
        ];

        const MAX_HAPPINESS = 100;
        const FEED_COOLDOWN_MS = 10 * 1000; // 10 seconds cooldown
        const HAPPINESS_DECAY_INTERVAL_MS = 12 * 60 * 60 * 1000; // 12 hours in milliseconds
        const HAPPINESS_DECAY_AMOUNT = 30; // 30% decrease

        // --- Utility Functions ---

        /**
         * Displays a custom message modal.
         * @param {string} message The message to display.
         */
        function showMessageModal(message) {
            messageModalText.textContent = message;
            messageModal.classList.remove('hidden');
        }

        /**
         * Hides the custom message modal.
         */
        function hideMessageModal() {
            messageModal.classList.add('hidden');
        }

        /**
         * Calculates and applies happiness decay based on time elapsed.
         * @param {object} pet The pet object to apply decay to.
         * @returns {number} The new happiness value after decay.
         */
        function applyHappinessDecay(pet) {
            const now = Date.now();
            // Use lastFed if available, otherwise createdAt
            const lastInteractionTime = pet.lastFed ? pet.lastFed.toDate().getTime() : (pet.createdAt ? pet.createdAt.toDate().getTime() : now);
            const timeSinceLastInteraction = now - lastInteractionTime;

            let decayedHappiness = pet.happiness;
            let periodsOfDecay = 0;

            if (timeSinceLastInteraction > 0) {
                periodsOfDecay = Math.floor(timeSinceLastInteraction / HAPPINESS_DECAY_INTERVAL_MS);
            }

            if (periodsOfDecay > 0) {
                decayedHappiness = Math.max(0, pet.happiness - (periodsOfDecay * HAPPINESS_DECAY_AMOUNT));
                console.log(`${pet.name} decayed by ${periodsOfDecay * HAPPINESS_DECAY_AMOUNT}% (${periodsOfDecay} periods). New happiness: ${decayedHappiness}`);
                // Update the pet in Firestore immediately to reflect decay
                const petRef = doc(db, `artifacts/${appId}/sharedPets`, pet.id);
                updateDoc(petRef, {
                    happiness: decayedHappiness,
                    // Update lastFed to now so decay calculation resets
                    lastFed: serverTimestamp()
                }).catch(error => {
                    console.error("Error updating pet happiness after decay:", error);
                });
            }
            return decayedHappiness;
        }


        /**
         * Renders the list of pets in the left panel.
         */
        function renderPetList() {
            petListContainer.innerHTML = ''; // Clear existing list
            if (userPets.length === 0) {
                petListContainer.innerHTML = '<p class="text-gray-400 text-center mt-4">No pets yet! Adopt one!</p>';
                selectedPetNameElement.textContent = "Adopt a Pet!";
                petImageContainer.innerHTML = '';
                petMoodEmoji.textContent = '';
                happinessBar.style.width = '0%';
                happinessText.textContent = 'Happiness: 0%';
                chewingMeterContainer.classList.add('hidden'); // Hide chewing meter
                chewingText.classList.add('hidden'); // Hide chewing text
                petNameInput.value = '';
                petNameInput.disabled = true;
                saveNameButton.disabled = true;
                foodSelectionGrid.classList.add('pointer-events-none', 'opacity-50'); // Disable food area
                stopSpeechBubbleTimer(); // Stop speech bubble if no pets
                stopChewingMeter(); // Stop chewing meter if no pets
                return;
            }

            foodSelectionGrid.classList.remove('pointer-events-none', 'opacity-50'); // Enable food area

            userPets.forEach(pet => {
                const petElement = document.createElement('div');
                petElement.id = `pet-${pet.id}`;
                petElement.classList.add(
                    'pet-item',
                    'p-3',
                    'rounded-lg',
                    'flex',
                    'items-center',
                    'space-x-3',
                    'cursor-pointer',
                    'transition-all',
                    'duration-200',
                    'ease-in-out',
                    'hover:bg-gray-700',
                    'border',
                    'border-gray-700'
                );

                if (pet.id === selectedPetId) {
                    petElement.classList.add('bg-purple-700', 'border-purple-500', 'shadow-lg');
                } else {
                    petElement.classList.add('bg-gray-700');
                }

                const petType = petTypes.find(type => type.id === pet.type);
                const petEmoji = petType ? petType.emoji : '‚ùì';

                petElement.innerHTML = `
                    <span class="text-4xl">${petEmoji}</span>
                    <div class="flex-grow text-left">
                        <p class="font-semibold text-lg text-white">${pet.name}</p>
                        <p class="text-sm text-gray-300">Happiness: ${pet.happiness}%</p>
                    </div>
                    <button class="delete-pet-button bg-red-500 hover:bg-red-600 text-white text-sm py-1 px-2 rounded-full shadow transition duration-300 ease-in-out" data-pet-id="${pet.id}">Delete</button>
                `;
                petElement.addEventListener('click', () => selectPet(pet.id));
                petListContainer.appendChild(petElement);

                // Add event listener for delete button
                petElement.querySelector('.delete-pet-button').addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent selecting the pet when deleting
                    deletePet(pet.id);
                });
            });

            // If no pet is selected, or the selected pet was deleted, select the first one if available
            if (!selectedPetId || !userPets.some(p => p.id === selectedPetId)) {
                if (userPets.length > 0) {
                    selectPet(userPets[0].id);
                } else {
                    // No pets left, reset display
                    selectedPetId = null;
                    renderPetDisplay(null);
                }
            } else {
                // Re-render the currently selected pet to ensure its display is up-to-date
                renderPetDisplay(userPets.find(p => p.id === selectedPetId));
            }
        }

        /**
         * Renders the details of the selected pet in the main display area.
         * @param {object|null} pet The pet object to display, or null if no pet is selected.
         */
        function renderPetDisplay(pet) {
            if (!pet) {
                selectedPetNameElement.textContent = "Select a Pet";
                petImageContainer.innerHTML = '<p class="text-gray-400 text-center">No pet selected.</p>';
                petMoodEmoji.textContent = '';
                happinessBar.style.width = '0%';
                happinessText.textContent = 'Happiness: 0%';
                chewingMeterContainer.classList.add('hidden'); // Hide chewing meter
                chewingText.classList.add('hidden'); // Hide chewing text
                petNameInput.value = '';
                petNameInput.disabled = true;
                saveNameButton.disabled = true;
                foodSelectionGrid.classList.add('pointer-events-none', 'opacity-50'); // Disable food area
                stopSpeechBubbleTimer(); // Stop speech bubble if no pets
                stopChewingMeter(); // Stop chewing meter if no pets
                return;
            }

            foodSelectionGrid.classList.remove('pointer-events-none', 'opacity-50'); // Enable food area
            petNameInput.disabled = false;
            saveNameButton.disabled = false;

            selectedPetNameElement.textContent = pet.name;
            petNameInput.value = pet.name;

            const petType = petTypes.find(type => type.id === pet.type);
            const petEmoji = petType ? petType.emoji : '‚ùì';
            petImageContainer.innerHTML = `
                <span class="text-9xl">${petEmoji}</span>
                <div id="speechBubble" class="speech-bubble absolute -top-16 left-1/2 -translate-x-1/2 hidden"></div>
            `; // Re-render pet emoji and speech bubble container

            // IMPORTANT FIX: Re-assign the global speechBubble variable to the newly created element
            speechBubble = document.getElementById('speechBubble');

            // Update happiness bar
            const happinessPercentage = Math.max(0, Math.min(100, pet.happiness));
            happinessBar.style.width = `${happinessPercentage}%`;
            happinessText.textContent = `Happiness: ${happinessPercentage}%`;

            // Update mood emoji
            let moodEmoji = 'üòê'; // Neutral
            if (happinessPercentage >= 80) {
                moodEmoji = 'üòä'; // Happy
            } else if (happinessPercentage >= 50) {
                moodEmoji = 'üôÇ'; // Content
            } else if (happinessPercentage < 20) {
                moodEmoji = 'üòî'; // Sad
            }
            petMoodEmoji.textContent = moodEmoji;

            // Add animation when happiness changes
            happinessBar.classList.remove('animate-pulse-happiness');
            void happinessBar.offsetWidth; // Trigger reflow
            happinessBar.classList.add('animate-pulse-happiness');

            renderFoodOptions(pet.type); // Render food options based on pet type
            startSpeechBubbleTimer(pet.type); // Start speech bubble for the selected pet

            // Chewing Meter logic for selected pet
            const now = Date.now();
            // Check if lastFed is a Firestore Timestamp object or null
            const lastFedTime = pet.lastFed ? pet.lastFed.toDate().getTime() : 0;
            const cooldownEndTime = lastFedTime + FEED_COOLDOWN_MS;

            if (pet.lastFed && cooldownEndTime > now) { // Only show if lastFed exists and cooldown is active
                startChewingMeter(pet.id, cooldownEndTime - now); // Start with remaining time
            } else {
                stopChewingMeter(); // Ensure it's hidden if cooldown is over or never fed
            }
        }

        /**
         * Renders the food options dynamically based on pet type.
         * @param {string} currentPetType The type of the currently selected pet.
         */
        function renderFoodOptions(currentPetType) {
            foodSelectionGrid.innerHTML = ''; // Clear existing food buttons

            foodItems.forEach(food => {
                const foodButton = document.createElement('button');
                // Split the class string into individual classes and add them
                const foodColorClasses = [`bg-${food.color}-500`, `hover:bg-${food.color}-600`];

                foodButton.classList.add(
                    'food-item',
                    ...foodColorClasses, // Use spread operator to add multiple classes
                    'text-white',
                    'text-4xl',
                    'py-4',
                    'rounded-xl',
                    'shadow-md',
                    'transition',
                    'duration-200',
                    'ease-in-out',
                    'transform',
                    'hover:scale-105',
                    'focus:outline-none',
                    `focus:ring-2`,
                    `focus:ring-${food.color}-400`
                );
                foodButton.dataset.food = food.emoji;
                foodButton.innerHTML = food.emoji;

                foodButton.addEventListener('click', () => feedPet(food));
                foodSelectionGrid.appendChild(foodButton);
            });
        }


        /**
         * Selects a pet to display and interact with.
         * @param {string} id The ID of the pet to select.
         */
        function selectPet(id) {
            if (selectedPetId === id) return; // Prevent re-rendering if same pet selected
            selectedPetId = id;
            renderPetList(); // Re-render list to highlight selected pet
            renderPetDisplay(userPets.find(p => p.id === selectedPetId));
        }

        /**
         * Handles feeding a pet.
         * @param {object} food The food item object.
         */
        async function feedPet(food) {
            if (!selectedPetId) {
                showMessageModal("Please select a pet first!");
                return;
            }

            const petToFeed = userPets.find(p => p.id === selectedPetId);
            if (!petToFeed) {
                showMessageModal("Selected pet not found.");
                return;
            }

            // Check cooldown
            if (petToFeed.lastFed && (Date.now() - petToFeed.lastFed.toDate().getTime() < FEED_COOLDOWN_MS)) {
                const remainingTime = Math.ceil((FEED_COOLDOWN_MS - (Date.now() - petToFeed.lastFed.toDate().getTime())) / 1000);
                showMessageModal(`Whoa there! ${petToFeed.name} is still chewing. Try again in ${remainingTime} seconds.`);
                return;
            }

            let happinessChange = food.defaultHappiness; // Start with default change
            let feedbackMessage = `${petToFeed.name} loved the ${food.emoji}! Happiness increased by ${food.defaultHappiness}%.`;

            // Check for specific pet food preferences
            const petSpecificPreferences = petFoodPreferences[petToFeed.type];
            if (petSpecificPreferences) {
                const specificPreference = petSpecificPreferences.find(pref => pref.emoji === food.emoji);
                if (specificPreference) {
                    happinessChange = specificPreference.change;
                    feedbackMessage = specificPreference.message; // Use specific message if available
                    if (happinessChange < 0) {
                        feedbackMessage = `${petToFeed.name} disliked the ${food.emoji}! ${feedbackMessage || `Happiness decreased by ${Math.abs(happinessChange)}%.`}`;
                    } else if (happinessChange > 0) {
                        feedbackMessage = `${petToFeed.name} loved the ${food.emoji}! ${feedbackMessage || `Happiness increased by ${happinessChange}%.`}`;
                    } else {
                        feedbackMessage = `${petToFeed.name} was indifferent to the ${food.emoji}.`;
                    }
                }
            }

            const newHappiness = Math.max(0, Math.min(MAX_HAPPINESS, petToFeed.happiness + happinessChange));

            try {
                // Update the pet in the public collection
                const petRef = doc(db, `artifacts/${appId}/sharedPets`, selectedPetId);
                await updateDoc(petRef, {
                    happiness: newHappiness,
                    lastFed: serverTimestamp() // Update last fed timestamp to now
                });

                // Visual feedback for feeding
                const foodEmojiElement = document.createElement('span');
                foodEmojiElement.textContent = food.emoji;
                foodEmojiElement.classList.add('absolute', 'text-6xl', 'animate-pop-food');
                // Position it near the pet
                const petRect = petImageContainer.getBoundingClientRect();
                foodEmojiElement.style.left = `${petRect.left + petRect.width / 2 - 30}px`; // Center food over pet
                foodEmojiElement.style.top = `${petRect.top + petRect.height / 2 - 30}px`;
                document.body.appendChild(foodEmojiElement);

                setTimeout(() => {
                    foodEmojiElement.remove();
                }, 500); // Remove after animation

                showMessageModal(feedbackMessage);
                startChewingMeter(selectedPetId, FEED_COOLDOWN_MS); // Start chewing meter after feeding

            } catch (error) {
                console.error("Error feeding pet:", error);
                showMessageModal("Failed to feed pet. Please try again.");
            }
        }

        /**
         * Saves the custom name for the selected pet.
         */
        async function savePetName() {
            if (!selectedPetId) {
                showMessageModal("Please select a pet first!");
                return;
            }
            const newName = petNameInput.value.trim();
            if (!newName) {
                showMessageModal("Pet name cannot be empty.");
                return;
            }

            try {
                // Update the pet's name in the public collection
                const petRef = doc(db, `artifacts/${appId}/sharedPets`, selectedPetId);
                await updateDoc(petRef, { name: newName });
                showMessageModal(`Name updated to "${newName}"!`);
            } catch (error) {
                console.error("Error updating pet name:", error);
                showMessageModal("Failed to update pet name. Please try again.");
            }
        }

        /**
         * Deletes a pet from the shared collection.
         * @param {string} petId The ID of the pet to delete.
         */
        async function deletePet(petId) {
            // IMPORTANT: Use a custom modal for confirmation instead of `confirm()`
            // as `confirm()` does not work in the Canvas environment.
            // For now, I'll keep `confirm()` as a placeholder, but in a real app,
            // you'd replace this with a custom UI modal.
            if (!confirm(`Are you sure you want to say goodbye to this pet?`)) {
                return; // User cancelled
            }

            try {
                // Delete the pet from the public collection
                const petRef = doc(db, `artifacts/${appId}/sharedPets`, petId);
                await deleteDoc(petRef);
                showMessageModal("Pet successfully adopted out!");
                if (selectedPetId === petId) {
                    selectedPetId = null; // Deselect if the current pet is deleted
                }
            } catch (error) {
                console.error("Error deleting pet:", error);
                showMessageModal("Failed to delete pet. Please try again.");
            }
        }

        /**
         * Starts the speech bubble timer for the selected pet.
         * @param {string} petType The type of the selected pet (e.g., 'cat', 'dog').
         */
        function startSpeechBubbleTimer(petType) {
            stopSpeechBubbleTimer(); // Clear any existing timer

            const filteredMessages = petMessages.filter(msg => {
                // Basic filtering for pet-specific messages
                if (petType === 'cat' && msg.includes('Purrrr')) return true;
                if (petType === 'dog' && msg.includes('Bark')) return true;
                if (petType === 'bird' && msg.includes('Chirp')) return true;
                if (petType === 'hamster' && msg.includes('Squeak')) return true;
                if (petType === 'fish' && msg.includes('Wiggle')) return true;
                // Include general messages
                return !msg.includes('Purrrr') && !msg.includes('Bark') && !msg.includes('Chirp') && !msg.includes('Squeak') && !msg.includes('Wiggle');
            });


            speechBubbleTimer = setInterval(() => {
                // Ensure speechBubble is not null before trying to use it
                if (selectedPetId && speechBubble) {
                    const randomMessage = filteredMessages[Math.floor(Math.random() * filteredMessages.length)];
                    speechBubble.textContent = randomMessage;
                    speechBubble.classList.remove('hidden');
                    speechBubble.classList.add('show'); // Trigger show animation

                    setTimeout(() => {
                        speechBubble.classList.remove('show');
                        // Hide completely after transition
                        setTimeout(() => {
                            speechBubble.classList.add('hidden');
                        }, 300); // Match CSS transition duration
                    }, 3000); // Message visible for 3 seconds
                } else {
                    stopSpeechBubbleTimer(); // Stop if no pet is selected or speechBubble element is not found
                }
            }, 5000); // New message every 5 seconds
        }

        /**
         * Stops the speech bubble timer and hides the bubble.
         */
        function stopSpeechBubbleTimer() {
            if (speechBubbleTimer) {
                clearInterval(speechBubbleTimer);
                speechBubbleTimer = null;
            }
            // Ensure speechBubble is not null before trying to use it
            if (speechBubble) {
                speechBubble.classList.remove('show');
                speechBubble.classList.add('hidden');
            }
        }

        /**
         * Starts the chewing meter animation.
         * @param {string} petId The ID of the pet that is chewing.
         * @param {number} initialDuration The initial duration of the chewing (e.g., FEED_COOLDOWN_MS or remaining time).
         */
        function startChewingMeter(petId, initialDuration) {
            stopChewingMeter(); // Stop any existing meter

            currentChewingPetId = petId;
            const startTime = Date.now();
            const cooldownDuration = initialDuration; // Use initialDuration for calculation

            chewingMeterContainer.classList.remove('hidden');
            chewingText.classList.remove('hidden');

            // Determine if it's a fresh chew (full animation) or a re-render (snap to current progress)
            const isFreshChew = (initialDuration === FEED_COOLDOWN_MS);

            if (!isFreshChew) {
                // If not a fresh chew, snap to current progress instantly
                chewingMeter.classList.remove('transition-all'); // Temporarily remove transition
                const currentPercentage = (initialDuration / FEED_COOLDOWN_MS) * 100;
                chewingMeter.style.width = `${currentPercentage}%`;
                void chewingMeter.offsetWidth; // Force reflow to apply style instantly
                chewingMeter.classList.add('transition-all'); // Re-add transition for subsequent animation
            } else {
                // For a fresh chew, ensure transition is active and start from full
                chewingMeter.classList.add('transition-all');
                chewingMeter.style.width = `100%`; // Start from full for the animation
            }


            function animateChewing() {
                const elapsedTime = Date.now() - startTime;
                const remainingTime = cooldownDuration - elapsedTime;

                if (remainingTime > 0) {
                    const percentage = (remainingTime / cooldownDuration) * 100;
                    chewingMeter.style.width = `${percentage}%`;
                    chewingTimer = requestAnimationFrame(animateChewing);
                } else {
                    stopChewingMeter();
                }
            }
            chewingTimer = requestAnimationFrame(animateChewing);
        }

        /**
         * Stops the chewing meter animation and hides the meter.
         */
        function stopChewingMeter() {
            if (chewingTimer) {
                cancelAnimationFrame(chewingTimer);
                chewingTimer = null;
            }
            chewingMeterContainer.classList.add('hidden');
            chewingText.classList.add('hidden');
            currentChewingPetId = null;
            chewingMeter.classList.add('transition-all'); // Ensure transition is back for next fresh chew
        }


        // --- Event Listeners ---
        messageModalCloseButton.addEventListener('click', hideMessageModal);

        addPetButton.addEventListener('click', () => {
            petTypeSelection.innerHTML = ''; // Clear previous options
            petTypes.forEach(type => {
                const typeButton = document.createElement('button');
                typeButton.classList.add(
                    'pet-type-button',
                    'bg-gray-700',
                    'hover:bg-purple-600',
                    'text-white',
                    'text-5xl',
                    'py-4',
                    'rounded-xl',
                    'shadow-md',
                    'transition',
                    'duration-200',
                    'ease-in-out',
                    'transform',
                    'hover:scale-105',
                    'focus:outline-none',
                    'focus:ring-2',
                    'focus:ring-purple-400'
                );
                typeButton.innerHTML = `<span class="block">${type.emoji}</span><span class="text-sm">${type.name}</span>`;
                typeButton.dataset.type = type.id;
                typeButton.addEventListener('click', () => {
                    // Remove selected class from others
                    document.querySelectorAll('.pet-type-button').forEach(btn => btn.classList.remove('border-4', 'border-purple-400'));
                    // Add selected class to current
                    typeButton.classList.add('border-4', 'border-purple-400');
                    addPetModal.dataset.selectedType = type.id;
                });
                petTypeSelection.appendChild(typeButton);
            });
            newPetNameInput.value = ''; // Clear input
            addPetModal.dataset.selectedType = ''; // Reset selected type
            addPetModal.classList.remove('hidden');
        });

        confirmAddPetButton.addEventListener('click', async () => {
            const selectedType = addPetModal.dataset.selectedType;
            const newName = newPetNameInput.value.trim();

            if (!selectedType) {
                showMessageModal("Please select a pet type!");
                return;
            }
            if (!newName) {
                showMessageModal("Please enter a name for your new pet!");
                return;
            }

            try {
                // Add a new pet document to the public collection
                const docRef = await addDoc(collection(db, `artifacts/${appId}/sharedPets`), {
                    name: newName,
                    type: selectedType,
                    happiness: 50, // Starting happiness
                    lastFed: null, // Set lastFed to null so it's not immediately in cooldown
                    createdAt: serverTimestamp()
                });
                addPetModal.classList.add('hidden');
                showMessageModal(`Welcome ${newName} to your Lil Guys family!`);
                selectPet(docRef.id); // Select the newly added pet
            } catch (error) {
                console.error("Error adding new pet:", error);
                showMessageModal("Failed to adopt pet. Please try again.");
            }
        });

        cancelAddPetButton.addEventListener('click', () => {
            addPetModal.classList.add('hidden');
        });

        saveNameButton.addEventListener('click', savePetName);
        petNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                savePetName();
            }
        });

        // Event listener for the food selection grid (delegated)
        foodSelectionGrid.addEventListener('click', (event) => {
            const foodButton = event.target.closest('.food-item');
            if (foodButton) {
                const foodEmoji = foodButton.dataset.food;
                const food = foodItems.find(item => item.emoji === foodEmoji);
                if (food) {
                    feedPet(food);
                }
            }
        });

        // --- Firebase Authentication and Data Listener ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUserId = user.uid;
                userIdDisplay.textContent = currentUserId;
                console.log("Authenticated with user ID:", currentUserId);

                if (unsubscribePets) {
                    unsubscribePets();
                }

                const q = query(collection(db, `artifacts/${appId}/sharedPets`));
                unsubscribePets = onSnapshot(q, (snapshot) => {
                    let updatedPets = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                    // Apply decay to each pet as it's loaded/updated
                    updatedPets = updatedPets.map(pet => {
                        const decayedHappiness = applyHappinessDecay(pet);
                        return { ...pet, happiness: decayedHappiness };
                    });

                    userPets = updatedPets;
                    userPets.sort((a, b) => (a.createdAt?.toDate() || 0) - (b.createdAt?.toDate() || 0));
                    renderPetList();
                    loadingOverlay.classList.add('hidden');
                }, (error) => {
                    console.error("Error fetching pets:", error);
                    showMessageModal("Failed to load Lil Guys. Please check your internet connection and Firebase rules.");
                    loadingOverlay.classList.add('hidden');
                });

            } else {
                try {
                    // Always attempt anonymous sign-in first for general use.
                    // The __initial_auth_token is primarily for Canvas environment authentication.
                    await signInAnonymously(auth);
                    console.log("Signed in anonymously.");
                } catch (error) {
                    console.error("Error during anonymous authentication:", error);
                    showMessageModal("Failed to authenticate. Please try refreshing the page.");
                    loadingOverlay.classList.add('hidden');
                }
            }
        });

        // --- PWA Manifest Setup (dynamic blob for self-contained immersive) ---
        const manifestContent = {
            "name": "Lil Guys Pet Care",
            "short_name": "Lil Guys",
            "start_url": ".",
            "display": "standalone",
            "background_color": "#1f2937",
            "theme_color": "#1f2937",
            "icons": [
                {
                    "src": "https://placehold.co/192x192/6b46c1/FFFFFF?text=üêæ",
                    "sizes": "192x192",
                    "type": "image/png"
                },
                {
                    "src": "https://placehold.co/512x512/6b46c1/FFFFFF?text=üêæ",
                    "sizes": "512x512",
                    "type": "image/png"
                }
            ]
        };

        const blob = new Blob([JSON.stringify(manifestContent)], { type: 'application/json' });
        const manifestUrl = URL.createObjectURL(blob);
        document.querySelector('link[rel="manifest"]').href = manifestUrl;

        // Initial render (will be updated by onSnapshot)
        renderPetList();
    </script>
</body>
</html>
